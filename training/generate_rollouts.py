#!/usr/bin/env python3
"""
Poker RL Training Data Generator

Requires Python 3.9+

This script generates rollouts (complete poker hand trajectories) for training
Reinforcement Learning agents. Each rollout contains:
  - States: Game observations at each decision point
  - Actions: Decisions made by agents
  - Rewards: Final outcomes (chips won/lost)

The data is generated by simulating poker hands using the C++ API server,
which provides deterministic, stateless game simulation.

Usage:
    # Basic usage - generate 100 rollouts
    python generate_rollouts.py --num-rollouts 100

    # Custom configuration
    python generate_rollouts.py \
        --num-rollouts 1000 \
        --num-players 3 \
        --small-blind 25 \
        --big-blind 50 \
        --starting-chips 2000 \
        --output data/training_data.json \
        --seed 42

    # Use different agent types
    python generate_rollouts.py --num-rollouts 500 --agent-type random
"""

import argparse
import json
import random
import time
import subprocess
from pathlib import Path
from typing import Any

# Import model version from config
from config import MODEL_VERSION

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    print("⚠️  Warning: requests library not found, falling back to curl subprocess")
    print("   For better performance: uv sync")


# =============================================================================
# Simple Output Helpers
# =============================================================================

def print_success(msg: str):
    print(f"✓ {msg}")


def print_error(msg: str):
    print(f"✗ {msg}")


def print_info(msg: str):
    print(f"ℹ {msg}")


def print_header(msg: str):
    print(f"\n{'='*60}")
    print(msg)
    print(f"{'='*60}\n")


# =============================================================================
# Bet Sizing Utilities
# =============================================================================

# Granular bet size buckets as percentages of pot
BET_SIZE_BUCKETS = [0.10, 0.25, 0.33, 0.50, 0.75, 1.0, 1.5, 2.0, 3.0]
BET_SIZE_LABELS = ['10%', '25%', '33%', '50%', '75%', '100%', '150%', '200%', '300%']


def calculate_bet_amount(pot: int, size_fraction: float, min_amount: int, max_amount: int) -> int:
    """
    Calculate bet amount based on pot size and constraints.
    
    Args:
        pot: Current pot size
        size_fraction: Fraction of pot to bet (e.g., 0.5 for 50%)
        min_amount: Minimum legal bet/raise
        max_amount: Maximum bet/raise (player chips)
    
    Returns:
        Bet amount within legal constraints
    """
    # Calculate target amount
    target = int(pot * size_fraction)
    
    # Enforce constraints
    amount = max(min_amount, target)
    amount = min(max_amount, amount)
    
    return amount


def select_random_bet_size() -> tuple[float, str]:
    """
    Randomly select a bet size from the granular buckets.
    
    Returns:
        Tuple of (size_fraction, label)
    """
    idx = random.randint(0, len(BET_SIZE_BUCKETS) - 1)
    return BET_SIZE_BUCKETS[idx], BET_SIZE_LABELS[idx]


# =============================================================================
# Agent Implementations
# =============================================================================

class Agent:
    """Base agent class - all agents inherit from this"""
    
    def __init__(self, player_id: str, name: str):
        self.player_id = player_id
        self.name = name
    
    def select_action(self, state: dict[str, Any], legal_actions: list[str]) -> tuple[str, int, str]:
        """
        Select an action based on current state.
        
        Args:
            state: Dictionary containing complete game state
            legal_actions: List of legal action strings (e.g., ["fold", "call", "raise"])
        
        Returns:
            tuple: (action_type, amount, action_label)
                - action_type: string like "call", "raise", "fold"
                - amount: integer for bet/raise amount, 0 otherwise
                - action_label: granular action label like "bet_50%", "raise_100%", etc.
        """
        raise NotImplementedError("Agents must implement select_action()")


class RandomAgent(Agent):
    """
    Random Agent - Takes random legal actions
    
    This agent uniformly samples from all legal actions. Useful for:
    - Baseline comparison
    - Initial exploration
    - Testing game mechanics
    
    Strategy: No strategy, pure randomness
    """
    
    def select_action(self, state: dict[str, Any], legal_actions: list[str]) -> tuple[str, int, str]:
        """Randomly select a legal action with granular bet sizing"""
        # Don't select all_in too often (it's always legal but boring)
        if 'all_in' in legal_actions and len(legal_actions) > 1:
            # 80% chance to exclude all_in from random selection
            if random.random() < 0.8:
                filtered_actions = [a for a in legal_actions if a != 'all_in']
                action = random.choice(filtered_actions)
            else:
                action = random.choice(legal_actions)
        else:
            action = random.choice(legal_actions)
        
        amount = 0
        action_label = action  # Default label is the action itself
        
        # If action is raise, choose a random bet size from granular buckets
        if action == "raise":
            min_raise_total = state.get('min_raise_total', state.get('big_blind', 20))
            max_raise = state['player_chips']
            pot = state.get('pot', 0)
            
            # Select random bet size bucket
            size_fraction, size_label = select_random_bet_size()
            amount = calculate_bet_amount(pot, size_fraction, min_raise_total, max_raise)
            action_label = f'raise_{size_label}'
        
        elif action == "bet":
            min_bet = state.get('min_bet', state.get('big_blind', 20))
            max_bet = state['player_chips']
            pot = state.get('pot', 0)
            
            # Select random bet size bucket
            size_fraction, size_label = select_random_bet_size()
            amount = calculate_bet_amount(pot, size_fraction, min_bet, max_bet)
            action_label = f'bet_{size_label}'
        
        return (action, amount, action_label)


class CallAgent(Agent):
    """
    Call Agent - Always calls or checks when possible
    
    This agent is passive, never raising. Useful for:
    - Testing aggressive opponents
    - Baseline comparison (calling stations)
    
    Strategy: Call/check when possible, fold when forced to
    """
    
    def select_action(self, state: dict[str, Any], legal_actions: list[str]) -> tuple[str, int, str]:
        """Always prefer call/check"""
        if "check" in legal_actions:
            return ("check", 0, "check")
        elif "call" in legal_actions:
            return ("call", 0, "call")
        else:
            # Must fold
            return ("fold", 0, "fold")


class TightAgent(Agent):
    """
    Tight Agent - Only plays premium hands
    
    This agent folds most hands and only plays strong starting hands.
    Useful for understanding tight-aggressive strategy.
    
    Strategy: 
    - Play premium pairs (AA, KK, QQ, JJ, TT)
    - Play strong broadway hands (AK, AQ)
    - Fold everything else preflop
    - Post-flop: bet strong hands, fold weak ones
    """
    
    PREMIUM_RANKS = ['A', 'K', 'Q', 'J', 'T']
    
    def select_action(self, state: dict[str, Any], legal_actions: list[str]) -> tuple[str, int, str]:
        """Play tight - only premium hands"""
        hole_cards = state.get('hole_cards', [])
        stage = state.get('stage', 'PREFLOP')
        
        if stage == 'PREFLOP':
            # Extract ranks
            if len(hole_cards) == 2:
                rank1 = hole_cards[0][0]
                rank2 = hole_cards[1][0]
                
                # Premium pair or strong broadway
                is_premium = (rank1 == rank2 and rank1 in self.PREMIUM_RANKS) or \
                           (rank1 in ['A', 'K'] and rank2 in ['A', 'K'])
                
                if is_premium:
                    if "raise" in legal_actions:
                        # Aggressive raise with premium hands - use 100% pot sizing
                        min_raise_total = state.get('min_raise_total', state.get('big_blind', 20))
                        pot = state.get('pot', 0)
                        amount = calculate_bet_amount(pot, 1.0, min_raise_total, state['player_chips'])
                        return ("raise", amount, "raise_100%")
                    elif "call" in legal_actions:
                        return ("call", 0, "call")
                    elif "check" in legal_actions:
                        return ("check", 0, "check")
                
                # Not premium - fold if there's a bet
                if "check" in legal_actions:
                    return ("check", 0, "check")
                else:
                    return ("fold", 0, "fold")
        
        # Post-flop: simplified strategy (check/call)
        if "check" in legal_actions:
            return ("check", 0, "check")
        elif "call" in legal_actions:
            # Only call reasonable bets
            pot = state.get('pot', 0)
            current_bet = state.get('current_bet', 0)
            if current_bet < pot * 0.5:  # Call if bet is less than 50% pot
                return ("call", 0, "call")
        
        return ("fold", 0, "fold")


class AggressiveAgent(Agent):
    """
    Aggressive Agent - Bets and raises frequently
    
    This agent puts pressure on opponents with aggressive betting.
    Useful for testing defensive play.
    
    Strategy:
    - Raise preflop frequently
    - Bet/raise post-flop
    - Rarely check or call
    """
    
    def select_action(self, state: dict[str, Any], legal_actions: list[str]) -> tuple[str, int, str]:
        """Play aggressive - bet and raise"""
        # Prefer raising
        if "raise" in legal_actions:
            min_raise_total = state.get('min_raise_total', state.get('big_blind', 20))
            pot = state.get('pot', 0)
            player_chips = state['player_chips']
            # Aggressive raise - use 75% pot sizing
            amount = calculate_bet_amount(pot, 0.75, min_raise_total, player_chips)
            return ("raise", amount, "raise_75%")
        
        # Bet if no current bet
        if "bet" in legal_actions:
            pot = state.get('pot', 0)
            min_bet = state.get('min_bet', state.get('big_blind', 20))
            player_chips = state['player_chips']
            # Bet 50% of pot
            amount = calculate_bet_amount(pot, 0.50, min_bet, player_chips)
            return ("bet", amount, "bet_50%")
        
        # Call if we can't raise
        if "call" in legal_actions:
            return ("call", 0, "call")
        
        # Check if possible
        if "check" in legal_actions:
            return ("check", 0, "check")
        
        # Last resort: fold
        return ("fold", 0, "fold")


# =============================================================================
# Rollout Generator
# =============================================================================

class RolloutGenerator:
    """
    Generates poker rollouts using the C++ API server.
    
    A rollout is one complete poker hand from deal to showdown, containing:
    - All game states observed
    - All actions taken
    - Final rewards for each player
    
    This class handles:
    1. Communication with the C++ API server
    2. Agent action selection
    3. State extraction and formatting
    4. Reward calculation
    """
    
    def __init__(self, api_url: str = "http://localhost:8080/simulate"):
        """
        Initialize the rollout generator.
        
        Args:
            api_url: URL of the C++ poker API server
        """
        self.api_url = api_url
        self.rollout_count = 0
    
    def check_server(self) -> bool:
        """Check if the API server is running"""
        if HAS_REQUESTS:
            try:
                response = requests.post(
                    self.api_url,
                    json={"config": {"seed": 1}},
                    timeout=2
                )
                # Any response (even error) means server is up
                return True
            except requests.exceptions.RequestException:
                return False
        else:
            # Fallback to curl subprocess
            try:
                result = subprocess.run(
                    ["curl", "-s", "-o", "/dev/null", "-w", "%{http_code}",
                     "-X", "POST", self.api_url,
                     "-H", "Content-Type: application/json",
                     "-d", json.dumps({"config": {"seed": 1}})],
                    capture_output=True,
                    text=True,
                    timeout=2
                )
                return result.stdout in ["200", "400", "404"]
            except (subprocess.TimeoutExpired, FileNotFoundError):
                return False
    
    def extract_state(self, game_state: dict, player_id: str) -> dict[str, Any]:
        """
        Extract RL-relevant state for a specific player.
        
        This converts the full game state into a format suitable for RL:
        - Only information visible to the player
        - Normalized and structured
        - Contains all relevant decision-making info
        
        Args:
            game_state: Full game state from API
            player_id: ID of the player whose perspective we want
        
        Returns:
            Dictionary containing RL state representation
        """
        # Find the player
        player = None
        for p in game_state['players']:
            if p['id'] == player_id:
                player = p
                break
        
        if player is None:
            return {}
        
        # Extract config values
        config = game_state.get('config', {})
        big_blind = config.get('bigBlind', 20)
        small_blind = config.get('smallBlind', 10)
        
        # Extract action constraints from API
        action_constraints = game_state.get('actionConstraints', {})
        
        # Extract state
        state = {
            'player_id': player_id,
            'hole_cards': player.get('holeCards', []),
            'community_cards': game_state.get('communityCards', []),
            'pot': game_state.get('pot', 0),
            'current_bet': game_state.get('currentBet', 0),
            'min_raise': game_state.get('minRaise', big_blind),
            'player_chips': player.get('chips', 0),
            'player_bet': player.get('bet', 0),
            'player_total_bet': player.get('totalBet', 0),
            'stage': game_state.get('stage', ''),
            'num_players': len(game_state['players']),
            'num_active': sum(1 for p in game_state['players'] if p.get('isInHand', False)),
            'position': player.get('position', 0),
            'is_dealer': player.get('isDealer', False),
            'is_small_blind': player.get('isSmallBlind', False),
            'is_big_blind': player.get('isBigBlind', False),
            'big_blind': big_blind,
            'small_blind': small_blind,
            # Add action constraints from API
            'to_call': action_constraints.get('toCall', 0),
            'min_bet': action_constraints.get('minBet', big_blind),
            'min_raise_total': action_constraints.get('minRaiseTotal', big_blind),
        }
        
        return state
    
    def get_legal_actions(self, game_state: dict, player_id: str) -> list[str]:
        """
        Determine legal actions for a player in current state.
        
        Uses the API-provided legal actions from actionConstraints.
        
        Args:
            game_state: Full game state from API
            player_id: ID of the player
        
        Returns:
            List of legal action strings
        """
        # Use API-provided legal actions
        action_constraints = game_state.get('actionConstraints', {})
        
        # Check if the API says the player can act
        if not action_constraints.get('canAct', False):
            return []
        
        # Return the legal actions from the API
        return action_constraints.get('legalActions', [])
    
    def generate_rollout(
        self,
        agents: list[Agent],
        config: dict[str, Any],
        max_steps: int = 1000,
        verbose: bool = False
    ) -> dict[str, Any]:
        """
        Generate a single rollout (complete poker hand).
        
        This is the main method that:
        1. Sets up the game with agents
        2. Runs the hand step by step
        3. Collects states, actions, and rewards
        4. Returns structured training data
        
        Args:
            agents: List of Agent objects to play the hand
            config: Game configuration (blinds, chips, seed, etc.)
            max_steps: Maximum actions before aborting (safety)
            verbose: Whether to print detailed progress
        
        Returns:
            Dictionary containing complete rollout data
        """
        rollout_id = self.rollout_count
        self.rollout_count += 1
        
        if verbose:
            print_info(f"Generating rollout {rollout_id}...")
        
        # Initialize rollout data
        rollout = {
            'rollout_id': rollout_id,
            'game_seed': config.get('seed', random.randint(0, 1000000)),
            'num_players': len(agents),
            'config': config,
            'states': [],
            'actions': [],
            'rewards': {},
            'terminal_state': None
        }
        
        # Build history
        history = []
        
        # Add all players
        for agent in agents:
            history.append({
                'type': 'addPlayer',
                'playerId': agent.player_id,
                'playerName': agent.name
            })
        
        # Get initial state (after players added)
        response = self._call_api(config, history)
        if not response['success']:
            print_error(f"Failed to initialize game: {response.get('error', 'Unknown error')}")
            return rollout
        
        game_state = response['gameState']
        
        # Record initial chips for reward calculation
        initial_chips = {}
        for player_data in game_state['players']:
            initial_chips[player_data['id']] = config.get('startingChips', 1000)
        
        # Main game loop
        step = 0
        # Terminal stages: Complete, Showdown (case-insensitive)
        terminal_stages = {'complete', 'showdown'}
        
        while step < max_steps:
            step += 1
            
            # Check if game is in terminal state (case-insensitive)
            current_stage = game_state.get('stage', '').lower()
            if current_stage in terminal_stages:
                break
            
            # Get current player
            current_player_id = game_state.get('currentPlayerId')
            if not current_player_id or current_player_id == 'none':
                # No current player - game might be transitioning or complete
                break
            
            # Find the agent for current player
            agent = None
            for a in agents:
                if a.player_id == current_player_id:
                    agent = a
                    break
            
            if agent is None:
                print_error(f"No agent found for player {current_player_id}")
                break
            
            # Extract state for this player
            state = self.extract_state(game_state, current_player_id)
            
            # Get legal actions - this returns empty list if player can't act
            legal_actions = self.get_legal_actions(game_state, current_player_id)
            
            if not legal_actions:
                # No legal actions - game might be transitioning or player can't act
                # This is normal at end of betting rounds, just advance
                break
            
            # Agent selects action
            action_type, amount, action_label = agent.select_action(state, legal_actions)
            
            # Record state and action
            rollout['states'].append(state)
            action_record = {
                'type': 'playerAction',
                'playerId': current_player_id,
                'action': action_type,
                'amount': amount,
                'action_label': action_label  # Store granular action label
            }
            rollout['actions'].append(action_record)
            
            # Apply action to history
            history.append(action_record)
            
            # Get new state
            response = self._call_api(config, history)
            if not response['success']:
                error_msg = response.get('error', 'Unknown')
                print_error(f"Failed to process action: {error_msg}")
                print_error(f"  Rollout {rollout_id}, Step {step}")
                print_error(f"  Player: {current_player_id}, Action: {action_type}, Amount: {amount}")
                print_error(f"  Stage: {state.get('stage')}, Legal actions: {legal_actions}")
                print_error(f"  Current bet: {state.get('current_bet')}, Player bet: {state.get('player_bet')}, Min raise: {state.get('min_raise')}")
                print_error(f"  Player chips: {state.get('player_chips')}")
                if 'details' in response:
                    print_error(f"  Details: {response['details']}")
                # Print the full response for debugging
                print_error(f"  Full response: {response}")
                break
            
            game_state = response['gameState']
            
            if verbose and step % 5 == 0:
                print(f"  Step {step}: {current_player_id} {action_type} (stage: {game_state['stage']})")
        
        # Calculate rewards (chips won/lost)
        final_chips = {}
        for player_data in game_state['players']:
            player_id = player_data['id']
            final_chips[player_id] = player_data['chips']
            rollout['rewards'][player_id] = final_chips[player_id] - initial_chips[player_id]
        
        # Record terminal state
        rollout['terminal_state'] = {
            'stage': game_state.get('stage'),
            'pot': game_state.get('pot', 0),
            'final_chips': final_chips
        }
        
        if verbose:
            print_success(f"Rollout {rollout_id} complete: {len(rollout['states'])} states, rewards={rollout['rewards']}")
        
        return rollout
    
    def _call_api(self, config: dict, history: list[dict]) -> dict:
        """
        Call the C++ API server using requests (or curl fallback).
        
        Args:
            config: Game configuration
            history: Action history
        
        Returns:
            API response dictionary
        """
        payload = {
            'config': config,
            'history': history
        }
        
        if HAS_REQUESTS:
            # Preferred: use requests library
            try:
                response = requests.post(
                    self.api_url,
                    json=payload,
                    timeout=5
                )
                # Parse response body before raising for status
                try:
                    response_data = response.json()
                except json.JSONDecodeError:
                    response_data = {'success': False, 'error': 'Invalid JSON response'}
                
                # If status is not 200, but we got JSON, return that
                if response.status_code != 200:
                    if 'error' not in response_data:
                        response_data['error'] = f'HTTP {response.status_code}'
                    response_data['success'] = False
                    return response_data
                
                return response_data
            except requests.exceptions.RequestException as e:
                return {'success': False, 'error': str(e)}
            except json.JSONDecodeError as e:
                return {'success': False, 'error': f'Invalid JSON response: {e}'}
        else:
            # Fallback: use curl subprocess
            try:
                result = subprocess.run(
                    ["curl", "-s", "-X", "POST", self.api_url,
                     "-H", "Content-Type: application/json",
                     "-d", json.dumps(payload)],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                
                if result.returncode == 0:
                    return json.loads(result.stdout)
                else:
                    return {'success': False, 'error': f'curl failed with code {result.returncode}'}
            except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError) as e:
                return {'success': False, 'error': str(e)}


# =============================================================================
# Main Functions
# =============================================================================

def create_agents(num_players: int, agent_type: str = "random") -> list[Agent]:
    """
    Create a list of agents for the game.
    
    Args:
        num_players: Number of agents to create
        agent_type: Type of agent ("random", "call", "tight", "aggressive", "mixed")
    
    Returns:
        List of Agent objects
    """
    agents = []
    
    for i in range(num_players):
        player_id = f"p{i}"
        player_name = f"Player{i}"
        
        if agent_type == "random":
            agents.append(RandomAgent(player_id, player_name))
        elif agent_type == "call":
            agents.append(CallAgent(player_id, player_name))
        elif agent_type == "tight":
            agents.append(TightAgent(player_id, player_name))
        elif agent_type == "aggressive":
            agents.append(AggressiveAgent(player_id, player_name))
        elif agent_type == "mixed":
            # Mix different agent types
            agent_types = [RandomAgent, CallAgent, TightAgent, AggressiveAgent]
            AgentClass = random.choice(agent_types)
            agents.append(AgentClass(player_id, player_name))
        else:
            # Default to random
            agents.append(RandomAgent(player_id, player_name))
    
    return agents


def main() -> int:
    """Main entry point for rollout generation"""
    parser = argparse.ArgumentParser(
        description="Generate RL training data by simulating poker hands",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate 100 rollouts with default settings
  python generate_rollouts.py --num-rollouts 100

  # Generate 1000 rollouts with 3 players and custom settings
  python generate_rollouts.py --num-rollouts 1000 --num-players 3 \\
      --small-blind 25 --big-blind 50 --starting-chips 2000

  # Use different agent types
  python generate_rollouts.py --num-rollouts 500 --agent-type tight

  # Save to specific file
  python generate_rollouts.py --num-rollouts 100 \\
      --output data/my_training_data.json
        """
    )
    
    # Rollout configuration
    parser.add_argument('--num-rollouts', type=int, default=100,
                      help='Number of rollouts to generate (default: 100)')
    parser.add_argument('--output', type=str, default=f'/tmp/pokersim/data_v{MODEL_VERSION}/rollouts.json',
                      help=f'Output file path (default: /tmp/pokersim/data_v{MODEL_VERSION}/rollouts.json)')
    
    # Game configuration
    parser.add_argument('--num-players', type=int, default=2,
                      help='Number of players (2-10, default: 2)')
    parser.add_argument('--small-blind', type=int, default=10,
                      help='Small blind amount (default: 10)')
    parser.add_argument('--big-blind', type=int, default=20,
                      help='Big blind amount (default: 20)')
    parser.add_argument('--starting-chips', type=int, default=1000,
                      help='Starting chip stack (default: 1000)')
    parser.add_argument('--seed', type=int, default=None,
                      help='Starting random seed (default: random)')
    
    # Agent configuration
    parser.add_argument('--agent-type', type=str, default='random',
                      choices=['random', 'call', 'tight', 'aggressive', 'mixed'],
                      help='Type of agents to use (default: random)')
    
    # Other options
    parser.add_argument('--api-url', type=str, default='http://localhost:8080/simulate',
                      help='API server URL (default: http://localhost:8080/simulate)')
    parser.add_argument('--verbose', action='store_true',
                      help='Print detailed progress')
    parser.add_argument('--max-steps', type=int, default=1000,
                      help='Maximum steps per rollout (default: 1000)')
    
    args = parser.parse_args()
    
    # Print header
    print_header("Poker RL Training Data Generator")
    
    # Create output directory
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Initialize generator
    print_info("Initializing rollout generator...")
    generator = RolloutGenerator(api_url=args.api_url)
    
    # Check if server is running
    print_info("Checking API server connection...")
    if not generator.check_server():
        print_error(f"Cannot connect to API server at {args.api_url}")
        print_info("Make sure the C++ API server is running:")
        print_info("  cd ../api")
        print_info("  ./build/poker_api 8080")
        return 1
    print_success("Connected to API server")
    
    # Generate rollouts
    print_info(f"Generating {args.num_rollouts} rollouts...")
    print_info(f"  Players: {args.num_players}")
    print_info(f"  Agent type: {args.agent_type}")
    print_info(f"  Blinds: {args.small_blind}/{args.big_blind}")
    print_info(f"  Starting chips: {args.starting_chips}")
    print()
    
    rollouts = []
    start_time = time.time()
    
    for i in range(args.num_rollouts):
        # Create agents
        agents = create_agents(args.num_players, args.agent_type)
        
        # Game configuration
        config = {
            'smallBlind': args.small_blind,
            'bigBlind': args.big_blind,
            'startingChips': args.starting_chips,
            'minPlayers': args.num_players,
            'maxPlayers': args.num_players,
            'seed': (args.seed + i) if args.seed is not None else random.randint(0, 1000000)
        }
        
        # Generate rollout
        rollout = generator.generate_rollout(
            agents=agents,
            config=config,
            max_steps=args.max_steps,
            verbose=args.verbose
        )
        
        rollouts.append(rollout)
        
        # Progress indicator
        if not args.verbose and (i + 1) % 10 == 0:
            elapsed = time.time() - start_time
            rate = (i + 1) / elapsed
            eta = (args.num_rollouts - i - 1) / rate
            print(f"  Progress: {i+1}/{args.num_rollouts} rollouts ({rate:.1f}/s, ETA: {eta:.1f}s)")
    
    # Save rollouts
    print()
    print_info(f"Saving {len(rollouts)} rollouts to {args.output}...")
    with open(args.output, 'w') as f:
        json.dump(rollouts, f, indent=2)
    print_success(f"Saved to {args.output}")
    
    # Statistics
    total_time = time.time() - start_time
    print()
    print_header("Generation Statistics")
    print(f"Total rollouts: {len(rollouts)}")
    print(f"Total time: {total_time:.2f} seconds")
    print(f"Average time per rollout: {total_time/len(rollouts):.3f} seconds")
    
    total_states = sum(len(r['states']) for r in rollouts)
    print(f"Total states collected: {total_states}")
    print(f"Average states per rollout: {total_states/len(rollouts):.1f}")
    
    return 0


if __name__ == "__main__":
    exit(main())

